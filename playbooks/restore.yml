- name: Restoration variables setup
  hosts: localhost
  connection: local
  gather_facts: False
  vars_files:
    - ../environment/group_vars/all/all.yml

  tasks:
    - name: Gather the values for all of the storage variables
      set_fact:
        storage_vars_list:  "{% for i in lookup('varnames', '^compositional_.+_storage', wantlist=True) %}{{ lookup('vars', i) }},{% endfor %}"

    - name: Return a list of droplet snapshots
      uri:
        url: 'https://api.digitalocean.com/v2/snapshots?resource_type=droplet'
        body_format: 'json'
        headers:
          Authorization: "Bearer {{ do_oauth_token }}"
      register: droplet_snapshots

    - debug:
        var: droplet_snapshots
        verbosity: 2

    - name: Get the values for the newest snapshot
      set_fact:
        droplet_snapshot: "{{
            droplet_snapshots['json']['snapshots']
            | selectattr('name', 'match', environment_domain | replace('.', '-'))
            | list
            | sort(attribute='name')
            | last
            | default('False')
          }}"

    - name: Set the image to create a droplet from
      set_fact:
        do_droplet_image: "{{ droplet_snapshot['id'] }}"
      when: droplet_snapshot | bool

    - name: Check for DNS entry
      command: dig +short "{{ environment_domain }}"
      register: dns_check

- name: Deploy droplet
  import_playbook: 'create_droplet.yml'

- name: Put droplet into groups
  hosts: localhost
  connection: local
  gather_facts: False
  vars_files:
    - ../environment/group_vars/all/all.yml

  tasks:
    - name: Add newly-created droplet to new and compositional groups
      add_host:
        name: "{{ hostvars['localhost']['my_droplet']['data']['ip_address'] }}"
        groups:
          - 'compositional'
          - 'new'

- name: Establish Connection
  hosts: compositional
  gather_facts: False
  vars_files:
    - ../environment/group_vars/all/all.yml
  tasks:
    - name: Add Droplet to DNS while it finishes spinning up
       # Yes, these lines should end with trailing whitespace
      command: >
        ../bin/cloudns.py 
        --apiuser "{{ cloudns_api_user }}" 
        --apipass "{{ cloudns_api_pass }}" 
        --address "{{ hostvars['localhost']['new_floating_ip']['data']['floating_ip']['ip'] }}" 
        --fqdn "{{ environment_domain }}" 
        --type {% if hostvars['localhost']['dns_check']['stdout'] == "" %}'add'{% else %}'modify'{% endif %}
      delegate_to: localhost

    - name: Establish an ssh connection
      wait_for_connection:

    - name: Install with-lock-ex package
      apt:
        name: chiark-utils-bin
        state: latest
        update_cache: True
        autoremove: True
      register: restore_install_with_lock_first
      # Here we're also saying to continue on if we're facing a 'could not get lock'
      # error, since we can handle that later.
      failed_when:
        - restore_install_with_lock_first['msg'] is defined
        - not restore_install_with_lock_first['msg'] | regex_search('Failed to lock apt|Could not get lock')

    - name: Install with-lock-ex package
      apt:
        name: chiark-utils-bin
        state: latest
        update_cache: True
        autoremove: True
      register: restore_install_with_lock_second
      retries: 60
      delay: 5
      until:
        - restore_install_with_lock_second['msg'] is not defined
      when:
        - restore_install_with_lock_first['msg'] is defined
        - restore_install_with_lock_first['msg'] | regex_search('Failed to lock apt|Could not get lock')

- name: Implement block storage if necessary
  import_playbook: 'create_block_storage.yml'
  when: "'remote' in hostvars['localhost']['storage_vars_list'].split(',')"

- name: Install services before data restoration
  import_playbook: 'install_skeleton.yml'

- name: Restore the filesystem-level backups
  import_playbook: 'restore_files.yml'

- name: Restore the database backups
  import_playbook: 'restore_mariadb.yml'

- name: Install services after data restoration
  import_playbook: 'install_services.yml'

- name: Update the hosts file with the new droplet's address
  hosts: localhost
  connection: local
  gather_facts: True
  vars_files:
    - ../environment/group_vars/all/all.yml

  tasks:
    - name: Register realpath of hosts.yml file
      local_action:
        module: shell
        cmd: realpath ../environment/hosts.yml
      register: hosts_realpath

    - name: Replace the old server's IP with the new server's IP in the hosts.yml file
      local_action:
        module: shell
        cmd: ../bin/replace_host.py -i "{{ groups['new'][0] }}" -f "{{ hosts_realpath['stdout'].strip() }}"

    - name: Add the hosts.yml file with the new host present
      local_action:
        module: shell
        cmd: git --git-dir={{ '/'.join(hosts_realpath['stdout'].split('/')[:-1]) }}/.git add hosts.yml
        chdir: ../environment/

    - name: Commit the hosts.yml file with the new host present
      local_action:
        module: shell
        cmd: git --git-dir={{ '/'.join(hosts_realpath['stdout'].split('/')[:-1]) }}/.git commit -m "Updated to new inventory host {{ groups['new'][0] }} on {{ ansible_date_time['date'] }}-{{ ansible_date_time['hour'] }}-{{ ansible_date_time['minute'] }}" hosts.yml
        chdir: ../environment/

    - name: Push that latest commit
      local_action:
        module: shell
        cmd: git --git-dir={{ '/'.join(hosts_realpath['stdout'].split('/')[:-1]) }}/.git push
        chdir: ../environment/
